# FE-interview

####  http 协议

术语：

- RRT（Round-Trip Time）服务器交互往返时间



##### TCP协议与UDP协议-什么是三次握手与四次挥手

[TCP协议与UDP协议-什么是三次握手与四次挥手]: https://www.bilibili.com/video/BV1kV411j7hA/?vd_source=bd8e8bb85c031050816e139abcdf34f8	"tcp连接"

**为什么需要三次握手**：本质上来说就是为了在不可靠的信道上建立可靠的连接。

TCP连接如何解决丢包问题和乱序问题：

- TCP协议为没一个连接建立一个发送缓冲区，从建立连接后的第一个字节的序列号为0，后面每个字节的序列号就会增加1，发送数据时，从发送缓冲区去一部分数据组成发送报文，在其TCP协议头中，会附带序列号和长度，接收端在收到数据后，需要回复确认报文，确认报文中的ack等于接收序列号加长度==下一包数据需要发送的起始序列号。这样一问一答的方式，能够使发送端确认发送的数据，已经被对方收到，发送端也可以一次发送多包数据，接收端只需要回复一次ＡＣＫ就可以了。这样发送端可以把待发送的数据，分割成一系列的碎片，发送到对段，对端根据序列号和长度，在接收后重构出来完整的数据，假设其中丢失了某些数据包，在接收端可以要求发送端重传，ＴＣＰ链接是全双工的。

**四次挥手**：处于连接状态的客户端和服务端都可以发起关闭连接请求。此时需要四次挥手来进行连接的关闭，假设客户端主动发起关闭连接请求，他需要向服务端发起一包ＦＩＮ包，表示要关闭连接，资金进入终止等待１状态（第一次挥手）。服务端收到ＦＩＮ包，发送一包ＡＣＫ包，表示自己进入了关闭等待状态，客户端进入终止等待２状态（第二次挥手）。

​		服务端此时还可以发送未发送的数据，而客户端还可以接收数据，待服务端发送完数据后，发送一包ＦＩＮ包，进入最后确认状态（第三次挥手）。客户端收到之后回复ＡＣＫ包，进入超时等待状态，经过超时时间后关闭连接。而服务端收到ＡＣＫ包后立即关闭连接（第四次挥手）。　　为什么客户端需要超时等待时间，这是为了保证对方已收到ＡＣＫ包。因为假设客户端发送完最后一包ＡＣＫ包就释放了连接，一旦ＡＣＫ在网络中丢失，服务端将一直停留在最后确认状态。如果客户端发送最后一包ＡＣＫ包后，等待一段时间，这时服务端会因为没有收到ＡＣＫ包会重发ＦＩＮ包，客户端会响应这个ＦＩＮ包，重发ＡＣＫ包并刷新超时时间。这个机制跟三次握手一样也是为了保证在不可靠的网络链路中，进行可靠的链接断开确认。

**ＵＤＰ协议**：ＵＤＰ协议是基于非链接的。发送数据包就是简单的封装一下，然后从网卡发出去就可以了。对于网络中产生的丢包，ＵＤＰ并不能保证。

总结：

| 协议   | 优点     | 应用                                             | 适用场景                                                   |
| ------ | -------- | ------------------------------------------------ | ---------------------------------------------------------- |
| ＴＣＰ | 稳定可靠 | 传输文件、邮件、网页                             | 适用于对网络通讯质量要求较高的场景                         |
| ＵＤＰ | 速度快   | 域名查询，语音通话，视频直播、隧道网络（ＶＰＮ） | 适用于对实时性要求较高，但是对少量丢包并没有太大要求的场景 |

　　

---

#### 缓存机制

缓存一般针对的是静态资源。基本上短时间内不会变化的。

##### 强缓存：

对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通信。
在介绍强制缓存命中判断之前，我们首先来看一段响应头的部分信息：

```http
access-control-allow-origin:*
age：734978
content-length：40830
content-type: image/jpeg
cache-control： max-age=31536000
expires：Web，14 Fed 2021 12:23:42 GMT
```

其中与强缓存相关的两个字段是 `expires`和 `cache-control`，`expires`是在http1.0协议中声明的用来控制缓存失效日期时间戳的字段，它由服务器端指定后通过响应头告知浏览器，浏览器在接收到带有该字段的响应体后进行缓存。

若之后浏览器再次发起相同的资源请求，便会对比`expires`与本地当前时间戳，便会对比`expires`与本地当前的时间戳，如果当前请求的本地时间戳小与`expires`的值，则说明浏览器缓存的响应还未过期，可以直接使用而无须向服务端再次发起请求。只有当本地时间戳大于`expires`值发生缓存过期时，才允许重新向服务器发起请求。

从上述强制缓存是否过期的判断机制中不难看出，这个方式存在一个很大的漏洞，即对本地时间戳过分依赖，如果客户端本地的时间戳与服务器端的时间不同步，或者对客户端时间进行主动修改，那么对于缓存过期的判断可能就无法和预期相符。为了解决` expires`判断的局限性，从HTTP1.1协议开始新增了`cache-control`字段来对 `expires` 的功能进行扩展和完善。从上述代码中可见`cache-control` 设置了`maxage=3153600`的属性值来控制响应资源的有效期，它是一个以秒为单位的时间长度。表示该资源再被请求到后的1353600秒内有效，如此便可避免服务器端和客户端时间戳不同步而造成的问题。除此之外`cache-control`还可以配置一些其他属性值来更准确的控制缓存。

##### no-cache 和 no-store

设置`no-cache`并非像字面上的意思不使用缓存，其表示为强制进行协商缓存（后面会说），即对于每次发起的请求都不会再去判断强制缓存是否过期，而是直接与服务器协商来验证缓存的有效性，若缓存未过期，则会使用本地缓存。设置 `no-store`则表示禁正使用任何缓存策略，客户端的每次请求都需要服务器端给予全新的响应。`no-cache`和`no-store`是两个互斥的属性值，不能同时设置。

发送如下响应头可以关闭缓存。

```http
Cache-Control:no-store
```

指定`no-cache`或者`max-age=0`表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起HTTP请求，但当缓存内容仍有效时可以跳过HTTP响应体的下载。

```http
Cache-Control:max-age=0

Cache-Control:no-store
```

##### Private和Public

`private `和` public` 也是` cache-control`的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。

- 若资源响应头中的`cache-control`字段设置了`public`属性值，则表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。

- `private`则限制了响应资源只能被浏览器缓存，若未显式指定则默认值为`private`。

对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS文件和JavaScript文件。

```http
Cache-Control:public, max-age=315360000
```

##### max-age 和 s-maxage

`max-age`属性值会比`s-maxage`更常用，它表示服务器端告知客户端浏览器响应资源的过期时长。在一般项目的使用场景中基本够用，对于天型架构的项目通常会涉及使用各种代理服务器的情况，这就需要考虑缓存在代理服务器上的有效性问题。这便是`s-maxage`存在的意义，它表示缓存在代理服务哭中的过期时长，且仅当设置了`public`属性值时才有效.

由此可见` cache-control` 能作为`expires` 的完全替代方案，并且拥有其所不具备的一些缓存控制特性，在项目实践中使用它就足够了，自前`expires`还存在的唯一理由是考虑可用性方面的向下兼容。

##### 协商缓存：

顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之协商当前浏览器保存的本地缓存是否已经过期。
通常是采用所请求资源最近一次的修改时间戳来判断的，为了便于理解，下面来看一个例子：假设客户端浏览器需要向服务器请求一个`manifest.js`的JavaScript 文件资源，为了让该资源被再次请求时能通过协缓存的机制使用本地缓仔，那么首次返回该图片资源的响应头中应包含一个名为`last-modified`的字段，该字段的属性值为该JavaScript文件最近一次修改的时间戳，简略截取请求头与响应头的关键信息如下：

```http
Request URL: https://localhost:8080/index
Request Method:GET
last-modified: Wed, 22 Feb 2023 03:58:55 GMT
cache-control:	no-cache
```

当我们刷新网贞时，由于该JavaScript文件使用的是协商缓存，客户端浏览器无法确定本地缓存是否过期，所以需要向服务器发送一次GET请求，进行缓存有效性的协商，止次GET请求的请求头中需要包含一个`if-modified-since`字段，其值正是上次响应头中`last-modified`的字段值。
当服务器收到该请求后便会对比**请求资源当前的修改时间戳**与`if-modified-since`字段的值，如果二者相同则说明缓存未过期，可继续使用本地缓存，否则服务器重新返回全新的文件资源，简略截取请求头与响应头的关键信息如下：

```http
Request URL: https://localhost:8080/index
Request Method:GET
If-Modified-Since:Wed, 22 Feb 2023 03:58:55 GMT

//协商缓存有效的响应头
Status Code : 304 Not Modified
```

这里需要注意的是，协商缓存判断缓存有效的响应状态码是`304`，即缓存有效响应重定向到本地缓存上。这和强强制缓存有所不同，强制缓存若有效，则再次请求的响应状态码是`200`

##### last-modified的不足

通过`last-modified`所实现的协商缓存能够满足大部分的使用场景，但也存在两个比较明显的缺陷：

- 首先它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新，从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪，以及延长用户获取到自标资源的时间



- 其次标识文件资源修改的时间戳单位是秒，如果文件修改的速度非常快，假设在几白毫秒内完成，那么上述通过时间戳的万式来验证缓存的有效性，是无法识别出该次文件资源的更新的。

其实造成上述两种缺陷的原因相同，就是服务器无法仪依据资源修改的时间戳来识别出真正的更新，进而导致重新发起了请求，该重新请求却使用了缓存的Bug场景。

##### 基于ETag的协商缓存

为了弥补通过时间戳判断的不足，从日TTP1.1规范开始新增了一个ETag的头信息，即实体标签（Entity Tag）。
其内容主要是服务器为不同资源进行哈希运鼻所生成的一个学符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的 ETag标签值就会不同，因此可以使用ETag对文件资源进行更精准的变化感知。下面我们来看一个使用ETag进行协商缓存图片资源的示例，首次请求后的部分响应头关键信息如下：

```http
content-type: image/png
etag: "367-xTSu8TJFzH8BG07ECM0ekD+6aHs"
last-modified: Tue, 24 Nov 2020 16:02:51 GMT
content-length: 1071585
```

请求流程
Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下：
====第一次请求===
1.客户端发起 HTTP GET 请求一个文件；
2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如"2e681a-6-5d044840")(假设服务器支持Etag生成和已经开启了Etag).状态码200
====第二次请求===
1.客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d044840
2.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；
流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办？

答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.(不要陷入到底使用谁的问题怪圈)

##### ETage的不足

不像强制缓存中`cache-control`可以完全替代 `expires` 的功能，在协商缓存中，`ETag`并非` last-modified` 的替代方案而是一种补充方案，因为它依旧存在一些弊端。

- 一方面服务器对于生成文件资源的`ETag`需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成`ETag`的过程就会影响服务器的性能

- 另一方面`ETag`字段值的生成分为强验证和弱验证，强验证根据资源内容进行生成，能够保证每个字节都相同；弱验证则根据资源的部分属性值来生成，生成速度快但无法确保每个字节都相同，并且在服务器集群场景下，也会因为不够准确而降低协商缓存有效性验证的成功率，所以恰当的方式是粮据具体的资源使用场景选择恰当的缓存校验方式

##### 三、HTTP状态码及区别

- **200 form memory cache**
   不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。**浏览器关闭后，数据将不存在**（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。
- **200 from disk cache**
   不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，**关闭浏览器后，数据依然存在**，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。
- **304 Not Modified**
   访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。

| 状态 |       类型        |                                                         说明 |
| ---- | :---------------: | -----------------------------------------------------------: |
| 200  | form memory cache | 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中 |
| 200  |  form disk ceche  | 不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等 |
| 200  |   资源大小数值    |                                         从服务器下载最新资源 |
| 304  |     报文大小      |                       请求服务端发现资源没更新，使用本地资源 |

一般样式表会缓存在磁盘中，不会缓存到内存中，因为css样式加载一次即可渲染出页面。但是脚本可能会随时执行，如果把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的IO开销比较大，有可能会导致浏览器失去响应。

##### 缓存决策

前面我们较为详细地介绍了浏览器HTTP缓存的配置与验证细节，下面思考一下如何应用HTTP缓存技术来提升网站的性能。假设在不考虑客户端缓存容量与服务器算力的理想情况卡，我们当然希望客户端浏览器上的缓存触发率尽可能高，留存时间尽可能长，同时还要`ETag`实现当资源更新时进行高效的重新验证。
但实际情况往往是容量与算力都有限，因此就需要制定合适的缓存策略，来利用有限的资源达到最优的性能效果。明确能力的边界，力求在边界内做到最好。

#### SSE(server send event)服务器发送事件





#### webSocket





#### webpack





#### 浏览器渲染机制

浏览器从获取HTML到最终在屏幕上显示内容需要完成以下步骤：

1. 处理HTML标记并构建 DOM树。
2. 处理CSS标记并构建 CSSOM树。
3. 将DOM与CSSOM合并成一个render tree
4. 根据染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。



#### event loop

<img src="http://i0.hdslb.com/bfs/archive/6c9c02e332ac15ef63b9764933a6c1f9e82fda41.jpg" alt="事件环" style="zoom:200%;" />



网页有一个我们称之为主线程的东西，这里发生大量的事情，包括JavaScript运行，渲染，dom存放的地方。这意味着网页上大部分的活动都是具有确定性的顺序，我们不会同时运行多段代码去修改同一处DOM。

​		JavaScript是单线程的，js的执行和渲染是互斥的，如果主线程上的任务需要很长时间，那么js执行会阻止页面的加载渲染和交互。所以对于一些耗时较大的任务(如，settimeout)，通常我们会把他加到一个任务队列（task queues）里面，当事件环中，同步任务堆栈执行完后，会查看宏任务队列里面那些已经得到结果并执行他。**The Render Setps**  S:渲染步骤是另一个弯道，涉及样式计算，收集所有的css，计算应用到元素上的样式，L：布局是创建一个渲染树，找出页面上所有的内容，P:以及元素的位置。然后创建实际的像素数据，绘制内容到页面上.

```jsx
button.addEventListener('click', event =>{
	while(true);
});
/**当用户点击事件后
浏览器：事件环我有个任务需要你执行。
事件环：好的没问题，我来处理。
但是这个任务永远不会结束，它一直执行JavaScript，一直占用着main thread,这样页面的渲染交互将会被卡死。
*/
```

```js
function loop(){
	setTimeout(loop,0)
}
loop();
/**这也是一个循环，在setTimeout的回调中调用自身，
*但是执行之后我们并没有造成页面交互的卡顿。
*这是因为，宏任务队列一次只会处理一个任务，处理完之后他又时间再去进行渲染步骤，不会直占用着main thread。
*但是如果你想运行与渲染有关的代码，不要把它放在任务中，因为任务在渲染的另一边，我们要把渲染代码放在渲染阶段之前，浏览器允许我们这样做，使用requestAnimationFrame可以做到这一点。
*/
//RAF回调，他作为渲染步骤的一部分发生，为了演示他的用法，下面是个盒子动画。我们用代码来移动盒子，每次我将盒子向前移动一个像素，然后使用requestAnimationFrame来创建一个循环。
function callback () {
	moveBoxForwardOnePixel();
    requestAnimationFrame(callback);
}
callback()
//这就是全部，但如果使用setTimeout代替requestAnimationFrame会怎么样呢？
function callback () {
	moveBoxForwardOnePixel();
    setTimeout(callback,0);
}
/*盒子移动的更快了，它的移动快了3.5倍，这意味着回调被更频繁的调用，这不是一件好事。
我们之前看到渲染可能在任务之间执行，但是不意味着必须，现实中，我们拿到一个任务，得出结果并不是马上渲染，何时渲染由浏览器决定且尽可能高效.只有值得更新才会渲染，如果没有改变就不会。如果浏览器运行在后台，没有显示，浏览器不会进行渲染，因为没有意义。大多数情况下，页面会以固定频率更新，每秒60次。60赫兹是最常见的，如果我们一秒钟内将页面样式改变1000次，浏览器不会运行渲染一千次，他将与显示器同步，仅渲染到显示器能够达到的频率。通常是每秒60次，否则就是浪费时间，渲染的东西用户也看不到。
*/
```

requestAnimationFrame适合将动画的工作打包起来，特别是如果你已经有动画运行，因为这样会节省很多重复的工作。（requestAnimationFrame是在渲染之前进行的，但是edge，和Safari他们是吧ＲＡＦ放在Ｐ后面）

###### MicroTasks

微任务初衷，90年代，浏览器想提供给开发者一种监控DOM变化的方法。w3c为了解决这个问题，提供了DOM变化事件。

```js
document.body.addEventListener('DOMNodeInserted',()=>{
	console.log('stuff added to <body>!');
})
//但是如果我们创建一百个span添加进去，会产生多少事件？
for(let i = 0; i<100; i++){
	const span = document.createElement('span');
    document.body.appendChild(span);
	span.textContent = 'Hello';
}
/**
100个span产生100个事件，还有100个额外事件，是为span设置文本的行为，并且冒泡。
这段简单的代码会产生两百个事件。
像这种简单的DOM修改，最终触发了成千上万的事件，即便你的回调函数很简单，很快也会变成大量的工作，降低性能。
我们真正想要的事，对于这种批量操作只产生一个事件，和之前RAF相似，我们希望浏览器暂时不要处理。等到一个合适的时间点。产生一个事件或者什么来代表所有的变化。
解决方案是使用DOM变化事件的观察者，他们创建了一个新队列就叫微任务队列。
任何JavaScript运行的时候都有可能执行微任务。
*/
//如果我们使用微任务创建一个无限循环会怎么样？
function loop(){
	Promise.resolve().then(loop);
}
loop();
//页面依然交互卡死。   

/**
Tasks(宏任务) Animation callback（RAF）   Microtasks（微任务队列）
这三种队列执行方式有些许区别。
tasks:每次只执行一个任务，如果另一个任务加进来，就添加到队列尾部。
Animation callback：动画回调会一直执行，知道队列中所有的任务都完成，如果动画回调内部又有动画回调。它们会在下一帧执行。
Microtasks：微任务同样也是一直执行，直到队列为空，但是，如果处理微任务的过程中有新的微任务加进来，加入添加的速度比执行快，那么就会永远执行微任务。事件环会阻塞，直到微任务队列完全清空，这就是它阻止渲染的原因。
*/
```

dom点击事件和js调用函数对执行栈的不同影响。



#### 常用的工具函数

- ##### 防抖和节流(debounce-throttle)



#### 类  class（语法糖）
